
> # Silicon CubeSat-2024 
> ## CubeSat 
![image](https://github.com/user-attachments/assets/e32dfb36-6480-4903-a882-e1b50f86cf57)


> ### What is CubeSat


  CubeSat or Cube Satellite is a type of miniaturized satellite used for space research. It is as smaller as that of 1U of CubeSat=10 cm with mass of 1-1.33kg(s). The CubeSat Project began as a collaborative effort between Prof. Jordi Puig-Suari at California Polytechnic State University (Cal Poly), San Luis Obispo, and Prof. Bob Twiggs at Stanford University’s Space Systems Development Laboratory (SSDL). 

  
![image](https://github.com/user-attachments/assets/df857623-9661-4b73-804d-fb8a59436ae2)

  
> ### Why Cubesat


   CubeSats are beneficial as-
 1. As weight and size is small, therefore it is cost effective.
 2. CubeSats can be used for a wide range of missions including Earth observation, scientific research, technology demonstration, communications, and more
 3. CubeSats adhere to standardized sizes (e.g., 1U, 2U, 3U, etc.), which makes them easier to design, build, and integrate into launch vehicles.
 4. CubeSats can be used to test new technologies or techniques in space with lower financial risk compared to larger or more expensive satellites.



> ## Dispenser System
 *A dispenser system refers to a mechanism or device used to release satellites, payloads, or CubeSats into space from a launch vehicle.
 It provides attachment to the launching vehicles.
 The first dispenser for CubeSats was the Poly-Picosatellite Orbital Deployer (P-POD). It was developed by Cal Poly, San Luis Obispo.*
 
![image](https://github.com/user-attachments/assets/9912b459-ddf2-4216-9360-94249497864f)



> ## ![image](https://github.com/user-attachments/assets/9b5b0ad7-a586-444c-9e48-d286478885c7)


 
> ## Minimal Payload


  *It refers to the basic set of components and functionalities necessary to support communication tasks between the satellite and ground stations or between satellites in space.
   The minimal payload is the basic equipment or instruments they carry to achieve their mission goals. It could be something as simple as a small camera for taking pictures of Earth or A basic radio for sending and receiving signals. These 
   payloads are designed to fit within the CubeSat's small size.*
  
![image](https://github.com/user-attachments/assets/b144cc6e-60fb-45af-b5bf-21162e2a9325)



> ## CubeSat Architecture
 *CubeSat architecture is the standardized design and structure of these small satellites. CubeSats are characterized by their modular and scalable architecture, which enables rapid and cost-effective development, deployment, and operation in space.*

![image](https://github.com/user-attachments/assets/d1ba4723-c246-452a-8110-1c687d9c65a5)
 

 ---
> ## CubeSat Communication System :-
   *Communication system of cubesat acts as a linkage between the satellite in space and the ground satellites.*
   Various components associated with communication system are:-

**Antennas:**
             CubeSats may use deployable antennas that unfold or extend after launch to optimize signal transmission and reception. Some cuesat uses fixed antennas that are integrated in the structure.

  
**Transrecievers:**
           Transceivers transmit signals to ground stations or other satellites and receive signals for command and data retrieval.     
           
  
**Frequency band:**        
           CubeSats operate in various frequency bands allocated for space communication, such as UHF (Ultra High Frequency), S-band, X-band, and others.

**Command and Telemetry:**     
           CubeSats transmit telemetry data to ground stations, providing information about the satellite's health, status, and operational parameters.    
           
  
  > ## Micro processors and Micro controller

  *Microprocesor is a subset of microcontrollers as microcontrollers are made up of microprocessor with some peripheral participants(such as touch semsors, bluetooth, wi-fi and many more).*
  
  The peripherial participants are:-

*1. Touch Sensor
2. Analog to Digital Converter (ADC)
3. Digitsl to Analog COnverter (DAC)
4.  Wi-fi
5. Bluetooth
6. Pulse Width Modulation (PWM).*
  
*Microprocessors and microcontrollers are integral components in satellite systems, contributing to overall functionality, data processing capabilities, communication efficiency, and mission success in various Earth observation, communication, scientific exploration, and technology demonstration missions.*   


*1. Uses of Micro-proessor:-*
- Microprocessors are used for overall control and management of system.
- It handles commands & data processing, and manages communication with ground station.
- Microprocessors contribute to satellite navigation systems by processing data from onboard sensors.

*2. Uses of Micro-controllers:-*
- Microcontrollers are utilized in satellites for embedded systems applications, such as controlling subsystems and instruments.
- Microcontrollers play a role in managing power distribution and ensuring efficient energy usage.
- Microcontrollers often implement fault detection mechanisms and autonomous recovery procedures to relieve anomalies and ensure satellite operational reliability.


> ## Basic Digital Modulation Methods

*Basic modulation techniques used to encode digital information onto an analog carrier signal for transmission over communication channels.*
There are three basic digital modulation types:-
- Amplitude Shift Keying (ASK):

   Amplitude Shift Keying starts with a high-frequency carrier signal, typically a sinusoidal wave, which acts as the carrier for transmitting digital information. The digital data to be transmitted is in the form of binary bits (0s and 1s).
  1 for higher amplitude and 0 for lower amplitude or no signal.

- Frequency Shift Keying (FSK):

  Fhase Shift Keying is a digital modulation technique where the frequency of a carrier signal is varied in accordance with the digital data signal being transmitted. It uses a sinusoidal carrier wave of a fixed amplitude and constant period. The digital data to be transmitted is typically in the form of binary bits (0s and 1s). 
  1 for higher frequency transmittes and 0 for lower frequency transmitted.


- Phase SHift Keying (PSK):

   Frequency Shift Keying is a digital modulation technique where the phase of the carrier signal is varied in discrete steps according to the digital data being transmitted which starts with a high-frequency sinusoidal carrier wave, which serves as the carrier for transmitting digital information. The digital data to be transmitted is typically in the form of binary bits (0s and 1s).
  
     Most common forms of PSK are Binary Phase Shift Keying (BPSK), Quadrature Phase Shift Keying (QPSK), and higher-order PSK such as 8-PSK or 16-PSK.
      In BPSK, two phase shifts are used: typically 0 degrees and 180 degrees. Each phase shift represents one binary digit (bit) while in QPSK, four phase shifts are used (0 degrees, 90 degrees, 180 degrees, and 270 degrees), allowing each symbol to represent two bits of binary data.

    ![image](https://github.com/user-attachments/assets/eb810331-e871-481f-b028-dd0c0e651416)


  > ## ELetromagnetic spectrum
    ![electromagnetic spectrum](https://github.com/user-attachments/assets/455c017f-8a1d-4ae3-8b93-31c975dbc9bb)



> # *LoRa (Long Range)* :-
   > ## *What is LoRa Module?*

 - A LoRa module refers to a device or a component that incorporates LoRa (Long Range) modulation technology for wireless communication.
 - LoRa is a modulation technique developed by Semtech that enables long-range communication with low power consumption.
 - It was developed by Cycleo, a company of Grenoble, France, and patented in 2014 and was  was later acquired by Semtech.
   

  > ## Key aspects of LoRa Modulation :

   - LoRa Modulation: It uses a sprad spectrum modulation technique to provide long-range communication with relatively lower power consumption.
   - Features: LoRa modules often include features such as error correction coding, adaptive data rate adjustment, and support for different spreading factors
   - LoRa uses license-free sub-gigahertz radio frequency bands((such as 433 MHz, 868 MHz or 915 MHz). LoRa modules often include features such as error 
correction coding, adaptive data rate adjustment, and support for different spreading factors.

     
![image](https://github.com/user-attachments/assets/9a0ed236-e651-4f6c-8a84-6b34d4175622)

![image](https://github.com/user-attachments/assets/172e496a-38a5-4866-ade4-e29760068847)

  > ### Shannon-Hartley Theorem

  Shannon–Hartley theorem tells the maximum rate at which information can be transmitted over a communications channel of a specified bandwidth in the presence of noise.
  Mathematically,

  
  $*C = Blog<sub>2</sub>(1 + \frac(S/N))*$
 
  
  where,
   C is the channnel capacity in bits per second ;
     
   B is the bandwidth of the channel in hertz ;
     
   S is the average received signal power over the bandwidth in watts ;
     
   N is the avg power of the noise and interference over the bandwidth in watts;
     
   S/N is the Signal to Noise Ratio (SNR).

   

## Introduction to CMOS VLSI Design:

   CMOS VLSI (Complementary Metal-Oxide-Semiconductor Very Large-Scale Integration) design refers to the process of designing ICs using CMOS technology.
   Cmos is a semiconductor technology used to fabricate most of today's digital integrated circuits. It employs both NMOS and PMOS transistors to provide low power consumption as well as higher packing density.
 
   > bonding pattern of cmos vlsi design:
![image](https://github.com/user-attachments/assets/3a233677-0ffc-437f-8414-b5c47a0bc40f)

> # Intoduction to Antennas

   Antennas are devices designed to transmit or receive electromagnetic waves. They are essential components in communication systems, allowing the transmission and reception of radio frequency (RF) signals. Antennas are used to convert electrical signals into electromagnetic waves or vice-versa.



> ### Two wire Antenna and eletric filed lines
![image](https://github.com/user-attachments/assets/feda2f1f-47f6-4f21-af45-bcfb9fd38ed2)

> ### Two wire Antenna and free space
![image](https://github.com/user-attachments/assets/293acadd-a60c-41d6-85f3-8946ac137ac8)



> ## Types of Antenna

   There are different typesof antenna used according to their different uses and frequencies.

  - Dipole Antenna:
       

       It is the Simplest form of antennas which are  often used for radio and television broadcasting.  A dipole antenna consists of a conductive wire or rod that is divided into two equal halves oriented in a straight line. The length of each half of the dipole antenna is typically half of the wavelength (λ/2) of the frequency.

   - Yagi-Uda Antenna:
   
   
      It is a directional antenna commonly used for communication in the high-frequency bands.
   It was devloped bytwo peoples of JApan in early 1920s. Yagi-Uda antenna is highly directional, meaning it focuses its radiation pattern in one direction while suppressing signals from other directions. Yagi-Uda antenna is highly 
   directional, meaning it focuses its radiation pattern in one direction while suppressing signals from other directions.

   - Parabolic Antenna:

     
       Its likely a disk shaped reflector consisting of feed point at its focal length. It is mostly used for satellite communication and long-distance microwave links.
 
   - Horn Antenna:
     
     Horn antennas are a type of directional antenna characterized by their horn-shaped structure. They are widely used in microwave and RF applications due to their ability to efficiently transmit and receive electromagnetic waves.

   - Helical Antenna:

        Horn antennas are helical-shaped directional antennas used for satellite communication, wireless systems, radar, and radio astronomy.

---
---
 # LAB EXERCISES

> ### Lab01:-

  
  blinking of light of dev board
 ```python
 #define LED 2
//the setup function runs once when you press reset or power to button
void setup() {
  // initialize digital pin LED_Builtin as an output.
  pinMode(LED, OUTPUT);
}

//the loop function runs over and over again forever
void loop() {
 digitalWrite(LED, HIGH);   //turn the LED on (HIGH is the voltage level)
 delay(1000);              // wait for a second
 digitalWrite(LED, LOW);   // turn the LED off by making the voltage high.
 delay(1000);             // wait for a second

}
```

 > ### Lab02:-
- Introduction to GPIO pins:
  
    GPIO stands for *General Purpose Input/Output*. GPIO pins are physical connections on a microcontroller that can be programmed to served as either digital input or output pins.

![image](https://github.com/user-attachments/assets/44255b59-2643-4759-aada-c8507a24cfbc)


*Code-*
```python
#define LED 15
//the setup function runs once when you press reset or power to button
void setup() {
  // initialize digital pin LED_Builtin as an output.
  pinMode(LED, OUTPUT);
}

//the loop function runs over and over again forever
void loop() {
 digitalWrite(LED, HIGH);   //turn the LED on (HIGH is the voltage level)
 delay(1000);              // wait for a second
 digitalWrite(LED, LOW);   // turn the LED off by making the voltage high.
 delay(1000);             // wait for a second

}

```


> ## Lab03:-

- Dimming LED using PWM

     *PWM stands for Pulse Width Modulation. It is a method used to generate analog-like signals using digital means, primarily by varying the width of the pulse in a periodic signal.*
```python
Dimming LED define 
const int PWM_CHANNEL = 0;    // ESP32 has 16 channels which can generate 16 independent waveforms
const int PWM_FREQ = 5000;     // Recall that Arduino Uno is ~490 Hz. Official ESP32 example uses 5,000Hz
const int PWM_RESOLUTION = 8; // We'll use same resolution as Uno (8 bits, 0-255) but ESP32 can go up to 16 bits 

// The max duty cycle value based on PWM resolution (will be 255 if resolution is 8 bits)
const int MAX_DUTY_CYCLE = (int)(pow(2, PWM_RESOLUTION) - 1); 

const int LED_OUTPUT_PIN = 13;

const int DELAY_MS = 4;  // delay between fade increments

void setup() {

  // Sets up a channel (0-15), a PWM duty cycle frequency, and a PWM resolution (1 - 16 bits) 
  // ledcSetup(uint8_t channel, double freq, uint8_t resolution_bits);
  ledcSetup(PWM_CHANNEL, PWM_FREQ, PWM_RESOLUTION);

  // ledcAttachPin(uint8_t pin, uint8_t channel);
  ledcAttachPin(LED_OUTPUT_PIN, MAX_DUTY_CYCLE);
}

void loop() {

  // fade up PWM on given channel
  for(int dutyCycle = 0; dutyCycle <= MAX_DUTY_CYCLE; dutyCycle++){   
    ledcWrite(PWM_CHANNEL, dutyCycle);
    delay(DELAY_MS);
  }

  // fade down PWM on given channel
  for(int dutyCycle = MAX_DUTY_CYCLE; dutyCycle >= 0; dutyCycle--){
    ledcWrite(PWM_CHANNEL, dutyCycle);   
    delay(DELAY_MS);
  }
}
```

> ## Lab07:-
- I2C-based OLED Display control:
  
```python

#include<SPI.h>
#include<Wire.h>
#include<Adafruit_GFX.h>
#include<Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128   //Display's width
#define SCREEN_HEIGHT 64   //display's height
#define OLED_RESET    4      //reset pin
#define SCREEN_ADDRESS 0x3C
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

void setup() {
  Serial.begin(9600);
  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);
  }
  delay(2000);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,00);
  display.println(F("Hello Sliconnites"));
  display.display();
  delay(2000);
}

void loop(){
  display.startscrollright(0x00,0X0F);
  delay(2000);
  display.stopscroll();
  delay(2000);
  display.startscrollleft(0x00,0X0F);
  delay(2000);
  display.stopscroll();
  delay(2000);
}
```


 
> # Lab9:-
- I2C OLED DISPLAY TEMPERATURE & HUMDITY SENSOSOR

  
```python
#include<Wire.h>
#include<Adafruit_GFX.h>
#include<Adafruit_SSD1306.h>
#include<Adafruit_Sensor.h>
#include "DHT.h"


#define SCREEN_WIDTH 128   //Display's width
#define SCREEN_HEIGHT 64   //display's height
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

#define DHT11PIN 26

DHT dht(DHT11PIN,DHT11);
void setup(){
   Serial.begin(9600);
   dht.begin();
  if (!display.begin(SSD1306_SWITCHCAPVCC,0X3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);
  }
  delay(2000);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,00);
  display.display();
  delay(2000);
  dht.begin();
  }
  void loop(){
    delay(5000);
   float humi = dht.readHumidity();
   float temp = dht.readTemperature();
   if(isnan(humi) || isnan(temp)){
    Serial.println("Failed to read from DHT sensor");
   }

   display.clearDisplay();
   
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,00);
  display.println("Temperature:");
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,10);
  display.print(temp);
  display.print("C");

  
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,35);
  display.println("Humidity:");
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,45);
  display.print(humi);
  display.print("%");

  display.display();
  

  }
  ```

